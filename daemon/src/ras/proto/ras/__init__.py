# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: auth.proto, daemon.proto, ntfy.proto, ntfy_signaling.proto, qr_payload.proto, sessions.proto, signaling.proto, terminal.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import List

import betterproto

from . import clipboard


class DeviceType(betterproto.Enum):
    """Device type for UI display"""

    UNKNOWN = 0
    LAPTOP = 1
    DESKTOP = 2
    SERVER = 3


class AuthErrorErrorCode(betterproto.Enum):
    UNKNOWN = 0
    INVALID_HMAC = 1
    INVALID_NONCE = 2
    TIMEOUT = 3
    PROTOCOL_ERROR = 4


class SessionStatus(betterproto.Enum):
    UNKNOWN = 0
    ACTIVE = 1
    CREATING = 2
    KILLING = 3


class KeyType(betterproto.Enum):
    KEY_UNKNOWN = 0
    KEY_ENTER = 1
    """Basic"""

    KEY_TAB = 2
    KEY_BACKSPACE = 3
    KEY_ESCAPE = 4
    KEY_DELETE = 5
    KEY_INSERT = 6
    KEY_UP = 10
    """Arrows"""

    KEY_DOWN = 11
    KEY_LEFT = 12
    KEY_RIGHT = 13
    KEY_HOME = 20
    """Navigation"""

    KEY_END = 21
    KEY_PAGE_UP = 22
    KEY_PAGE_DOWN = 23
    KEY_F1 = 30
    """Function keys"""

    KEY_F2 = 31
    KEY_F3 = 32
    KEY_F4 = 33
    KEY_F5 = 34
    KEY_F6 = 35
    KEY_F7 = 36
    KEY_F8 = 37
    KEY_F9 = 38
    KEY_F10 = 39
    KEY_F11 = 40
    KEY_F12 = 41
    KEY_CTRL_C = 50
    """Control characters (sent as special keys for clarity)"""

    KEY_CTRL_D = 51
    KEY_CTRL_Z = 52
    KEY_PASTE_HOST = 60
    """Special actions"""


class NotificationType(betterproto.Enum):
    UNSPECIFIED = 0
    APPROVAL_NEEDED = 1
    TASK_COMPLETED = 2
    ERROR_DETECTED = 3


class NtfySignalMessageMessageType(betterproto.Enum):
    OFFER = 0
    ANSWER = 1
    CAPABILITIES = 2
    DISCOVER = 3
    DISCOVER_RESPONSE = 4


class SignalErrorErrorCode(betterproto.Enum):
    UNKNOWN = 0
    INVALID_REQUEST = 1
    INVALID_SESSION = 2
    AUTHENTICATION_FAILED = 3
    RATE_LIMITED = 4
    INTERNAL_ERROR = 5


@dataclass(eq=False, repr=False)
class AuthEnvelope(betterproto.Message):
    """
    Sent over WebRTC data channel "ras-control"
     All messages wrapped in AuthEnvelope
    """

    challenge: "AuthChallenge" = betterproto.message_field(1, group="message")
    response: "AuthResponse" = betterproto.message_field(2, group="message")
    verify: "AuthVerify" = betterproto.message_field(3, group="message")
    success: "AuthSuccess" = betterproto.message_field(4, group="message")
    error: "AuthError" = betterproto.message_field(5, group="message")


@dataclass(eq=False, repr=False)
class AuthChallenge(betterproto.Message):
    """Server -> Client: Initial challenge"""

    nonce: bytes = betterproto.bytes_field(1)
    """32 random bytes (CSPRNG)"""


@dataclass(eq=False, repr=False)
class AuthResponse(betterproto.Message):
    """Client -> Server: Response to challenge + client's challenge"""

    hmac: bytes = betterproto.bytes_field(1)
    """HMAC-SHA256(auth_key, server_nonce)"""

    nonce: bytes = betterproto.bytes_field(2)
    """32 random bytes (CSPRNG) - client's challenge to server"""


@dataclass(eq=False, repr=False)
class AuthVerify(betterproto.Message):
    """Server -> Client: Server proves it knows the secret"""

    hmac: bytes = betterproto.bytes_field(1)
    """HMAC-SHA256(auth_key, client_nonce)"""


@dataclass(eq=False, repr=False)
class AuthSuccess(betterproto.Message):
    """Server -> Client: Authentication successful"""

    device_id: str = betterproto.string_field(1)
    """Device was registered/updated"""

    hostname: str = betterproto.string_field(2)
    """System hostname (e.g., "MacBook-Pro.local")"""

    device_type: "DeviceType" = betterproto.enum_field(3)
    """Device type for UI display"""


@dataclass(eq=False, repr=False)
class AuthError(betterproto.Message):
    """Either direction: Authentication failed"""

    code: "AuthErrorErrorCode" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class Session(betterproto.Message):
    id: str = betterproto.string_field(1)
    tmux_name: str = betterproto.string_field(2)
    display_name: str = betterproto.string_field(3)
    directory: str = betterproto.string_field(4)
    agent: str = betterproto.string_field(5)
    created_at: int = betterproto.int64_field(6)
    last_activity_at: int = betterproto.int64_field(7)
    status: "SessionStatus" = betterproto.enum_field(8)


@dataclass(eq=False, repr=False)
class SessionCommand(betterproto.Message):
    list: "ListSessionsCommand" = betterproto.message_field(1, group="command")
    create: "CreateSessionCommand" = betterproto.message_field(2, group="command")
    kill: "KillSessionCommand" = betterproto.message_field(3, group="command")
    rename: "RenameSessionCommand" = betterproto.message_field(4, group="command")
    get_agents: "GetAgentsCommand" = betterproto.message_field(5, group="command")
    get_directories: "GetDirectoriesCommand" = betterproto.message_field(
        6, group="command"
    )
    refresh_agents: "RefreshAgentsCommand" = betterproto.message_field(
        7, group="command"
    )


@dataclass(eq=False, repr=False)
class ListSessionsCommand(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CreateSessionCommand(betterproto.Message):
    directory: str = betterproto.string_field(1)
    agent: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class KillSessionCommand(betterproto.Message):
    session_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class RenameSessionCommand(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    new_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetAgentsCommand(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetDirectoriesCommand(betterproto.Message):
    parent: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class RefreshAgentsCommand(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SessionEvent(betterproto.Message):
    list: "SessionListEvent" = betterproto.message_field(1, group="event")
    created: "SessionCreatedEvent" = betterproto.message_field(2, group="event")
    killed: "SessionKilledEvent" = betterproto.message_field(3, group="event")
    renamed: "SessionRenamedEvent" = betterproto.message_field(4, group="event")
    activity: "SessionActivityEvent" = betterproto.message_field(5, group="event")
    error: "SessionErrorEvent" = betterproto.message_field(6, group="event")
    agents: "AgentsListEvent" = betterproto.message_field(7, group="event")
    directories: "DirectoriesListEvent" = betterproto.message_field(8, group="event")


@dataclass(eq=False, repr=False)
class SessionListEvent(betterproto.Message):
    sessions: List["Session"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SessionCreatedEvent(betterproto.Message):
    session: "Session" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SessionKilledEvent(betterproto.Message):
    session_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SessionRenamedEvent(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    new_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SessionActivityEvent(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    timestamp: int = betterproto.int64_field(2)


@dataclass(eq=False, repr=False)
class SessionErrorEvent(betterproto.Message):
    error_code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)
    session_id: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class Agent(betterproto.Message):
    name: str = betterproto.string_field(1)
    binary: str = betterproto.string_field(2)
    path: str = betterproto.string_field(3)
    available: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class AgentsListEvent(betterproto.Message):
    agents: List["Agent"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DirectoryEntry(betterproto.Message):
    name: str = betterproto.string_field(1)
    path: str = betterproto.string_field(2)
    is_directory: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class DirectoriesListEvent(betterproto.Message):
    parent: str = betterproto.string_field(1)
    entries: List["DirectoryEntry"] = betterproto.message_field(2)
    recent: List[str] = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class TerminalOutput(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    data: bytes = betterproto.bytes_field(2)
    sequence: int = betterproto.uint64_field(3)
    partial: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class TerminalInput(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    data: bytes = betterproto.bytes_field(2, group="input")
    special: "SpecialKey" = betterproto.message_field(3, group="input")
    resize: "TerminalResize" = betterproto.message_field(4, group="input")


@dataclass(eq=False, repr=False)
class SpecialKey(betterproto.Message):
    key: "KeyType" = betterproto.enum_field(1)
    modifiers: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class TerminalResize(betterproto.Message):
    cols: int = betterproto.uint32_field(1)
    rows: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class TerminalCommand(betterproto.Message):
    attach: "AttachTerminal" = betterproto.message_field(1, group="command")
    detach: "DetachTerminal" = betterproto.message_field(2, group="command")
    input: "TerminalInput" = betterproto.message_field(3, group="command")


@dataclass(eq=False, repr=False)
class AttachTerminal(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    from_sequence: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class DetachTerminal(betterproto.Message):
    session_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class TerminalEvent(betterproto.Message):
    output: "TerminalOutput" = betterproto.message_field(1, group="event")
    attached: "TerminalAttached" = betterproto.message_field(2, group="event")
    detached: "TerminalDetached" = betterproto.message_field(3, group="event")
    error: "TerminalError" = betterproto.message_field(4, group="event")
    skipped: "OutputSkipped" = betterproto.message_field(5, group="event")
    notification: "TerminalNotification" = betterproto.message_field(6, group="event")


@dataclass(eq=False, repr=False)
class TerminalNotification(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    type: "NotificationType" = betterproto.enum_field(2)
    title: str = betterproto.string_field(3)
    body: str = betterproto.string_field(4)
    snippet: str = betterproto.string_field(5)
    timestamp: int = betterproto.int64_field(6)


@dataclass(eq=False, repr=False)
class TerminalAttached(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    cols: int = betterproto.uint32_field(2)
    rows: int = betterproto.uint32_field(3)
    buffer_start_seq: int = betterproto.uint64_field(4)
    current_seq: int = betterproto.uint64_field(5)


@dataclass(eq=False, repr=False)
class TerminalDetached(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    reason: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class TerminalError(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    error_code: str = betterproto.string_field(2)
    message: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class OutputSkipped(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    from_sequence: int = betterproto.uint64_field(2)
    to_sequence: int = betterproto.uint64_field(3)
    bytes_skipped: int = betterproto.uint32_field(4)


@dataclass(eq=False, repr=False)
class ConnectionReady(betterproto.Message):
    """
    Sent by phone after ConnectionManager is set up and ready to receive encrypted messages
     Daemon should wait for this before sending InitialState
    """

    pass


@dataclass(eq=False, repr=False)
class Ping(betterproto.Message):
    timestamp: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class Pong(betterproto.Message):
    timestamp: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class Heartbeat(betterproto.Message):
    timestamp: int = betterproto.int64_field(1)
    sequence: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class Disconnect(betterproto.Message):
    reason: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class InitialState(betterproto.Message):
    """Sent to phone immediately after connection established"""

    sessions: List["Session"] = betterproto.message_field(1)
    agents: List["Agent"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ErrorResponse(betterproto.Message):
    error_code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class RasCommand(betterproto.Message):
    """Phone -> Daemon: All commands wrapped in RasCommand"""

    session: "SessionCommand" = betterproto.message_field(1, group="command")
    terminal: "TerminalCommand" = betterproto.message_field(2, group="command")
    clipboard: "clipboard.ClipboardMessage" = betterproto.message_field(
        3, group="command"
    )
    ping: "Ping" = betterproto.message_field(4, group="command")
    connection_ready: "ConnectionReady" = betterproto.message_field(5, group="command")
    heartbeat: "Heartbeat" = betterproto.message_field(6, group="command")
    disconnect: "Disconnect" = betterproto.message_field(7, group="command")


@dataclass(eq=False, repr=False)
class RasEvent(betterproto.Message):
    """Daemon -> Phone: All events wrapped in RasEvent"""

    session: "SessionEvent" = betterproto.message_field(1, group="event")
    terminal: "TerminalEvent" = betterproto.message_field(2, group="event")
    clipboard: "clipboard.ClipboardMessage" = betterproto.message_field(
        3, group="event"
    )
    pong: "Pong" = betterproto.message_field(4, group="event")
    initial_state: "InitialState" = betterproto.message_field(5, group="event")
    error: "ErrorResponse" = betterproto.message_field(6, group="event")
    heartbeat: "Heartbeat" = betterproto.message_field(7, group="event")


@dataclass(eq=False, repr=False)
class IpChangeNotification(betterproto.Message):
    """IP change notification payload (encrypted before sending to ntfy)"""

    ip: str = betterproto.string_field(1)
    port: int = betterproto.uint32_field(2)
    timestamp: int = betterproto.int64_field(3)
    nonce: bytes = betterproto.bytes_field(4)


@dataclass(eq=False, repr=False)
class NtfySignalMessage(betterproto.Message):
    """
    Message sent via ntfy for signaling relay
     Encrypted with signaling_key (AES-256-GCM) before sending
     Wire format: base64(IV + ciphertext + tag)
    """

    type: "NtfySignalMessageMessageType" = betterproto.enum_field(1)
    """Message type"""

    session_id: str = betterproto.string_field(2)
    """
    Session ID from QR code (must match pending session)
     Empty string for reconnection mode
    """

    sdp: str = betterproto.string_field(3)
    """
    SDP content in raw format (NOT JSON-wrapped).
     WebRTC offer or answer with full ICE candidates included.
     Must start with "v=" (SDP version line).
     Example: "v=0\r\no=- 12345 1 IN IP4 127.0.0.1\r\ns=-\r\n..."
    """

    device_id: str = betterproto.string_field(4)
    """Device info (required in OFFER, optional in ANSWER)"""

    device_name: str = betterproto.string_field(5)
    timestamp: int = betterproto.int64_field(6)
    """Replay protection"""

    nonce: bytes = betterproto.bytes_field(7)
    capabilities: "ConnectionCapabilities" = betterproto.message_field(8)
    """Connection capabilities (used with CAPABILITIES type)"""

    discovery: "DiscoveryResponse" = betterproto.message_field(9)
    """Discovery response (used with DISCOVER_RESPONSE type)"""


@dataclass(eq=False, repr=False)
class ConnectionCapabilities(betterproto.Message):
    """
    Connection capabilities for strategy negotiation.
     Exchanged before attempting connection to determine best method.
    """

    tailscale_ip: str = betterproto.string_field(1)
    """Tailscale VPN info (if available)"""

    tailscale_port: int = betterproto.int32_field(2)
    supports_webrtc: bool = betterproto.bool_field(3)
    """Supported connection methods"""

    supports_turn: bool = betterproto.bool_field(4)
    protocol_version: int = betterproto.int32_field(5)
    """Protocol version for compatibility"""


@dataclass(eq=False, repr=False)
class DiscoveryResponse(betterproto.Message):
    """
    Discovery response with all available IPs
     Sent in response to DISCOVER message
    """

    lan_ip: str = betterproto.string_field(1)
    """LAN IP (physical network interface)"""

    lan_port: int = betterproto.int32_field(2)
    vpn_ip: str = betterproto.string_field(3)
    """VPN IP (non-Tailscale VPN like WireGuard, OpenVPN)"""

    vpn_port: int = betterproto.int32_field(4)
    tailscale_ip: str = betterproto.string_field(5)
    """Tailscale IP (if on Tailscale network)"""

    tailscale_port: int = betterproto.int32_field(6)
    public_ip: str = betterproto.string_field(7)
    """Public IP (via STUN, may not be directly reachable)"""

    public_port: int = betterproto.int32_field(8)
    device_id: str = betterproto.string_field(9)
    """Device info"""

    timestamp: int = betterproto.int64_field(10)
    """Timestamp for freshness check"""


@dataclass(eq=False, repr=False)
class QrPayload(betterproto.Message):
    """
    QR code payload for pairing
     Encoded as base64 of serialized protobuf
    """

    version: int = betterproto.uint32_field(1)
    """Protocol version (currently 1)"""

    ip: str = betterproto.string_field(2)
    """Daemon's public IP address (IPv4 or IPv6)"""

    port: int = betterproto.uint32_field(3)
    """Daemon's HTTP signaling port"""

    master_secret: bytes = betterproto.bytes_field(4)
    """32-byte master secret (raw bytes, not base64)"""

    session_id: str = betterproto.string_field(5)
    """Session ID for signaling endpoint (16 bytes hex = 32 chars)"""

    ntfy_topic: str = betterproto.string_field(6)
    """ntfy topic for IP change notifications"""

    tailscale_ip: str = betterproto.string_field(7)
    """
    Optional: Daemon's Tailscale IP (if available)
     Allows direct connection when both devices are on Tailscale
    """

    tailscale_port: int = betterproto.uint32_field(8)
    """Optional: Daemon's Tailscale port (defaults to 9876 if not set)"""

    vpn_ip: str = betterproto.string_field(9)
    """
    Optional: Daemon's VPN IP (non-Tailscale VPN like WireGuard, OpenVPN)
     Fallback when LAN IP is not reachable but VPN is
    """

    vpn_port: int = betterproto.uint32_field(10)
    """Optional: Daemon's VPN port (same as main port if not set)"""


@dataclass(eq=False, repr=False)
class SignalRequest(betterproto.Message):
    """
    HTTP POST /signal/{session_id}
     Header: X-RAS-Signature: <hmac_hex>
     Header: X-RAS-Timestamp: <unix_timestamp>
    """

    sdp_offer: str = betterproto.string_field(1)
    """
    WebRTC SDP offer in raw format (NOT JSON-wrapped).
     Must start with "v=" (SDP version line).
     Example: "v=0\r\no=- 12345 1 IN IP4 127.0.0.1\r\ns=-\r\n..."
     Full ICE candidates should be included.
    """

    device_name: str = betterproto.string_field(2)
    """Device name (e.g., "Pixel 8")"""

    device_id: str = betterproto.string_field(3)
    """Device unique ID (generated on first app launch)"""


@dataclass(eq=False, repr=False)
class SignalResponse(betterproto.Message):
    sdp_answer: str = betterproto.string_field(1)
    """
    WebRTC SDP answer in raw format (NOT JSON-wrapped).
     Must start with "v=" (SDP version line).
     Example: "v=0\r\no=- 12345 1 IN IP4 127.0.0.1\r\ns=-\r\n..."
     Full ICE candidates should be included.
    """


@dataclass(eq=False, repr=False)
class SignalError(betterproto.Message):
    code: "SignalErrorErrorCode" = betterproto.enum_field(1)
    """Error code (generic, doesn't leak info)"""
