# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: auth.proto, qr_payload.proto, signaling.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass

import betterproto


class SignalErrorErrorCode(betterproto.Enum):
    UNKNOWN = 0
    INVALID_REQUEST = 1
    INVALID_SESSION = 2
    AUTHENTICATION_FAILED = 3
    RATE_LIMITED = 4
    INTERNAL_ERROR = 5


class AuthErrorErrorCode(betterproto.Enum):
    UNKNOWN = 0
    INVALID_HMAC = 1
    INVALID_NONCE = 2
    TIMEOUT = 3
    PROTOCOL_ERROR = 4


@dataclass(eq=False, repr=False)
class QrPayload(betterproto.Message):
    """
    QR code payload for pairing
     Encoded as base64 of serialized protobuf
    """

    version: int = betterproto.uint32_field(1)
    """Protocol version (currently 1)"""

    ip: str = betterproto.string_field(2)
    """Daemon's public IP address (IPv4 or IPv6)"""

    port: int = betterproto.uint32_field(3)
    """Daemon's HTTP signaling port"""

    master_secret: bytes = betterproto.bytes_field(4)
    """32-byte master secret (raw bytes, not base64)"""

    session_id: str = betterproto.string_field(5)
    """Session ID for signaling endpoint (16 bytes hex = 32 chars)"""

    ntfy_topic: str = betterproto.string_field(6)
    """ntfy topic for IP change notifications"""


@dataclass(eq=False, repr=False)
class SignalRequest(betterproto.Message):
    """
    HTTP POST /signal/{session_id}
     Header: X-RAS-Signature: <hmac_hex>
     Header: X-RAS-Timestamp: <unix_timestamp>
    """

    sdp_offer: str = betterproto.string_field(1)
    """WebRTC SDP offer (full ICE candidates included)"""

    device_name: str = betterproto.string_field(2)
    """Device name (e.g., "Pixel 8")"""

    device_id: str = betterproto.string_field(3)
    """Device unique ID (generated on first app launch)"""


@dataclass(eq=False, repr=False)
class SignalResponse(betterproto.Message):
    sdp_answer: str = betterproto.string_field(1)
    """WebRTC SDP answer (full ICE candidates included)"""


@dataclass(eq=False, repr=False)
class SignalError(betterproto.Message):
    code: "SignalErrorErrorCode" = betterproto.enum_field(1)
    """Error code (generic, doesn't leak info)"""


@dataclass(eq=False, repr=False)
class AuthEnvelope(betterproto.Message):
    """
    Sent over WebRTC data channel "ras-control"
     All messages wrapped in AuthEnvelope
    """

    challenge: "AuthChallenge" = betterproto.message_field(1, group="message")
    response: "AuthResponse" = betterproto.message_field(2, group="message")
    verify: "AuthVerify" = betterproto.message_field(3, group="message")
    success: "AuthSuccess" = betterproto.message_field(4, group="message")
    error: "AuthError" = betterproto.message_field(5, group="message")


@dataclass(eq=False, repr=False)
class AuthChallenge(betterproto.Message):
    """Server -> Client: Initial challenge"""

    nonce: bytes = betterproto.bytes_field(1)
    """32 random bytes (CSPRNG)"""


@dataclass(eq=False, repr=False)
class AuthResponse(betterproto.Message):
    """Client -> Server: Response to challenge + client's challenge"""

    hmac: bytes = betterproto.bytes_field(1)
    """HMAC-SHA256(auth_key, server_nonce)"""

    nonce: bytes = betterproto.bytes_field(2)
    """32 random bytes (CSPRNG) - client's challenge to server"""


@dataclass(eq=False, repr=False)
class AuthVerify(betterproto.Message):
    """Server -> Client: Server proves it knows the secret"""

    hmac: bytes = betterproto.bytes_field(1)
    """HMAC-SHA256(auth_key, client_nonce)"""


@dataclass(eq=False, repr=False)
class AuthSuccess(betterproto.Message):
    """Server -> Client: Authentication successful"""

    device_id: str = betterproto.string_field(1)
    """Device was registered/updated"""


@dataclass(eq=False, repr=False)
class AuthError(betterproto.Message):
    """Either direction: Authentication failed"""

    code: "AuthErrorErrorCode" = betterproto.enum_field(1)
