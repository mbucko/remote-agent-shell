# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: auth.proto, ntfy.proto, qr_payload.proto, signaling.proto
# plugin: python-betterproto
from dataclasses import dataclass

import betterproto


class AuthErrorErrorCode(betterproto.Enum):
    UNKNOWN = 0
    INVALID_HMAC = 1
    INVALID_NONCE = 2
    TIMEOUT = 3
    PROTOCOL_ERROR = 4


class SignalErrorErrorCode(betterproto.Enum):
    UNKNOWN = 0
    INVALID_REQUEST = 1
    INVALID_SESSION = 2
    AUTHENTICATION_FAILED = 3
    RATE_LIMITED = 4
    INTERNAL_ERROR = 5


@dataclass
class AuthEnvelope(betterproto.Message):
    """
    Sent over WebRTC data channel "ras-control" All messages wrapped in
    AuthEnvelope
    """

    challenge: "AuthChallenge" = betterproto.message_field(1, group="message")
    response: "AuthResponse" = betterproto.message_field(2, group="message")
    verify: "AuthVerify" = betterproto.message_field(3, group="message")
    success: "AuthSuccess" = betterproto.message_field(4, group="message")
    error: "AuthError" = betterproto.message_field(5, group="message")


@dataclass
class AuthChallenge(betterproto.Message):
    """Server -> Client: Initial challenge"""

    # 32 random bytes (CSPRNG)
    nonce: bytes = betterproto.bytes_field(1)


@dataclass
class AuthResponse(betterproto.Message):
    """Client -> Server: Response to challenge + client's challenge"""

    # HMAC-SHA256(auth_key, server_nonce)
    hmac: bytes = betterproto.bytes_field(1)
    # 32 random bytes (CSPRNG) - client's challenge to server
    nonce: bytes = betterproto.bytes_field(2)


@dataclass
class AuthVerify(betterproto.Message):
    """Server -> Client: Server proves it knows the secret"""

    # HMAC-SHA256(auth_key, client_nonce)
    hmac: bytes = betterproto.bytes_field(1)


@dataclass
class AuthSuccess(betterproto.Message):
    """Server -> Client: Authentication successful"""

    # Device was registered/updated
    device_id: str = betterproto.string_field(1)


@dataclass
class AuthError(betterproto.Message):
    """Either direction: Authentication failed"""

    code: "AuthErrorErrorCode" = betterproto.enum_field(1)


@dataclass
class IpChangeNotification(betterproto.Message):
    """IP change notification payload (encrypted before sending to ntfy)"""

    ip: str = betterproto.string_field(1)
    port: int = betterproto.uint32_field(2)
    timestamp: int = betterproto.int64_field(3)
    nonce: bytes = betterproto.bytes_field(4)


@dataclass
class QrPayload(betterproto.Message):
    """QR code payload for pairing Encoded as base64 of serialized protobuf"""

    # Protocol version (currently 1)
    version: int = betterproto.uint32_field(1)
    # Daemon's public IP address (IPv4 or IPv6)
    ip: str = betterproto.string_field(2)
    # Daemon's HTTP signaling port
    port: int = betterproto.uint32_field(3)
    # 32-byte master secret (raw bytes, not base64)
    master_secret: bytes = betterproto.bytes_field(4)
    # Session ID for signaling endpoint (16 bytes hex = 32 chars)
    session_id: str = betterproto.string_field(5)
    # ntfy topic for IP change notifications
    ntfy_topic: str = betterproto.string_field(6)


@dataclass
class SignalRequest(betterproto.Message):
    """
    HTTP POST /signal/{session_id} Header: X-RAS-Signature: <hmac_hex> Header:
    X-RAS-Timestamp: <unix_timestamp>
    """

    # WebRTC SDP offer (full ICE candidates included)
    sdp_offer: str = betterproto.string_field(1)
    # Device name (e.g., "Pixel 8")
    device_name: str = betterproto.string_field(2)
    # Device unique ID (generated on first app launch)
    device_id: str = betterproto.string_field(3)


@dataclass
class SignalResponse(betterproto.Message):
    # WebRTC SDP answer (full ICE candidates included)
    sdp_answer: str = betterproto.string_field(1)


@dataclass
class SignalError(betterproto.Message):
    # Error code (generic, doesn't leak info)
    code: "SignalErrorErrorCode" = betterproto.enum_field(1)
