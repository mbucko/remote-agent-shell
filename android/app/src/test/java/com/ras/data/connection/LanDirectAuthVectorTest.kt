package com.ras.data.connection

import com.ras.crypto.HmacUtils
import com.ras.crypto.KeyDerivation
import com.ras.crypto.hexToBytes
import com.ras.crypto.toHex
import com.ras.proto.LanDirectAuthRequest
import org.junit.jupiter.api.Assertions.assertArrayEquals
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNotEquals
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test

/**
 * Tests validating Android against shared LAN Direct auth test vectors.
 *
 * These vectors are generated by scripts/compute_test_vectors.py and shared
 * between Python daemon and Android app. They ensure both platforms produce
 * identical cryptographic outputs.
 *
 * These tests catch the double-derivation bug where Android called
 * deriveKey() on an already-derived authToken.
 *
 * Test vector values from: test-vectors/lan_direct_auth.json
 */
class LanDirectAuthVectorTest {

    companion object {
        // From test-vectors/lan_direct_auth.json
        private const val MASTER_SECRET_HEX =
            "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        private const val EXPECTED_AUTH_KEY_HEX =
            "bec0c3289e346d890ea330014e23e6e7cf95f82c8bd7f5f133850c89ac165a43"
        private const val DEVICE_ID = "test-device-abc123"
        private const val TIMESTAMP = 1706400000L
        private const val EXPECTED_SIGNATURE_HEX =
            "7069b4d01a7a4013f9453d29ea53139df51c7b5e595964e181dbec704dd8f412"
        private const val EXPECTED_PROTOBUF_HEX =
            "0a12746573742d6465766963652d6162633132331080b2d6ad061a4037303639623464303161376134303133663934353364323965613533313339646635316337623565353935393634653138316462656337303464643866343132"

        // Error case: double-derivation bug
        private const val WRONG_SIGNATURE_HEX =
            "08189c7271e2a3df18d9d37a8ec07f374eaad0a454a45dbed306694cac4130ca"
    }

    // ==================== Key Derivation ====================

    @Tag("unit")
    @Test
    fun `derive auth key matches test vector`() {
        val masterSecret = MASTER_SECRET_HEX.hexToBytes()

        val authKey = KeyDerivation.deriveKey(masterSecret, "auth")

        assertEquals(EXPECTED_AUTH_KEY_HEX, authKey.toHex())
    }

    // ==================== HMAC Computation ====================

    @Tag("unit")
    @Test
    fun `compute signaling HMAC matches test vector`() {
        val authKey = EXPECTED_AUTH_KEY_HEX.hexToBytes()

        val signature = HmacUtils.computeSignalingHmac(
            authKey, DEVICE_ID, TIMESTAMP, ByteArray(0)
        )

        assertEquals(EXPECTED_SIGNATURE_HEX, signature.toHex())
    }

    // ==================== Protobuf Serialization ====================

    @Tag("unit")
    @Test
    fun `build protobuf matches test vector`() {
        val authRequest = LanDirectAuthRequest.newBuilder()
            .setDeviceId(DEVICE_ID)
            .setTimestamp(TIMESTAMP)
            .setSignature(EXPECTED_SIGNATURE_HEX)
            .build()

        assertEquals(EXPECTED_PROTOBUF_HEX, authRequest.toByteArray().toHex())
    }

    @Tag("unit")
    @Test
    fun `parse protobuf from vector bytes`() {
        val protoBytes = EXPECTED_PROTOBUF_HEX.hexToBytes()

        val request = LanDirectAuthRequest.parseFrom(protoBytes)

        assertEquals(DEVICE_ID, request.deviceId)
        assertEquals(TIMESTAMP, request.timestamp)
        assertEquals(EXPECTED_SIGNATURE_HEX, request.signature)
    }

    // ==================== Full Flow ====================

    @Tag("unit")
    @Test
    fun `full flow - derive key, compute HMAC, build protobuf matches vector`() {
        val masterSecret = MASTER_SECRET_HEX.hexToBytes()

        // Step 1: Derive auth key
        val authKey = KeyDerivation.deriveKey(masterSecret, "auth")
        assertEquals(EXPECTED_AUTH_KEY_HEX, authKey.toHex())

        // Step 2: Compute HMAC (same as Python's compute_signaling_hmac)
        val signature = HmacUtils.computeSignalingHmac(
            authKey, DEVICE_ID, TIMESTAMP, ByteArray(0)
        )
        assertEquals(EXPECTED_SIGNATURE_HEX, signature.toHex())

        // Step 3: Build protobuf
        val authRequest = LanDirectAuthRequest.newBuilder()
            .setDeviceId(DEVICE_ID)
            .setTimestamp(TIMESTAMP)
            .setSignature(signature.toHex())
            .build()
        assertEquals(EXPECTED_PROTOBUF_HEX, authRequest.toByteArray().toHex())
    }

    // ==================== Double-Derivation Bug ====================

    @Tag("unit")
    @Test
    fun `using master_secret directly produces wrong HMAC`() {
        val masterSecret = MASTER_SECRET_HEX.hexToBytes()

        // The buggy path: use master_secret directly as HMAC key
        val wrongSignature = HmacUtils.computeSignalingHmac(
            masterSecret, DEVICE_ID, TIMESTAMP, ByteArray(0)
        )

        // Must match the known wrong signature from the vector
        assertEquals(WRONG_SIGNATURE_HEX, wrongSignature.toHex())

        // Must NOT match the correct signature
        assertNotEquals(EXPECTED_SIGNATURE_HEX, wrongSignature.toHex())
    }

    @Tag("unit")
    @Test
    fun `correct flow uses derived key not master_secret`() {
        val masterSecret = MASTER_SECRET_HEX.hexToBytes()

        // Correct: derive first, then HMAC
        val authKey = KeyDerivation.deriveKey(masterSecret, "auth")
        val correctSignature = HmacUtils.computeSignalingHmac(
            authKey, DEVICE_ID, TIMESTAMP, ByteArray(0)
        )

        // Wrong: HMAC with master_secret directly
        val wrongSignature = HmacUtils.computeSignalingHmac(
            masterSecret, DEVICE_ID, TIMESTAMP, ByteArray(0)
        )

        // They must differ - this is the exact bug we're testing for
        assertNotEquals(correctSignature.toHex(), wrongSignature.toHex())
        assertEquals(EXPECTED_SIGNATURE_HEX, correctSignature.toHex())
        assertEquals(WRONG_SIGNATURE_HEX, wrongSignature.toHex())
    }
}
